# source ~/Documents/bash-command-timer/bash_command_timer.sh

# OS Specific Commands
if [[ "$OSTYPE" == 'linux'* ]]; then
  alias open="xdg-open"
elif [[ "$OSTYPE" =~ "darwin" ]]; then
  export CLICOLOR=1
  export LSCOLORS=GxFxCxDxBxegedabagaced
  alias unmount="diskutil unmountDisk $1"
  alias eject="diskutil unmountDisk $1"
  export BASH_SILENCE_DEPRECATION_WARNING=1
fi

# Source sensitive environment variables
if [ -f "$HOME/.authorizations" ]; then
  . "$HOME/.authorizations"  
fi

# Git branch in terminal.
function git_branch_name() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}

function git_remote_name() {
  git remote -v 2> /dev/null | head -1 | cut -f2 | cut -d' ' -f1 | rev | cut -d '/' -f1 | rev | cut -d'.' -f1
}

function k8s_current_context() {
  if [ -f "$HOME/.kube/config" ]; then
    export CURRENT_CONTEXT=$(grep "current-context" "$HOME/.kube/config" | cut -d" " -f2)
    CURRENT_NAMESPACE=$(k8s_current_namespace)
    echo "[$CURRENT_CONTEXT@$CURRENT_NAMESPACE]"
  fi
}

function k8s_current_namespace() {
  CURRENT_CONTEXT=$(grep "current-context" "$HOME/.kube/config" | cut -d" " -f2)
  yq '.contexts[] | select(.context.cluster == env(CURRENT_CONTEXT)).context.namespace' ~/.kube/config
}

function git_all_in_one() {
  REMOTE=$(git remote -v 2> /dev/null | head -1 | cut -f2 | cut -d' ' -f1 | rev | cut -d '/' -f1 | rev | cut -d'.' -f1)
  BRANCH=$(git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
  if [ ! -z "$REMOTE" ]; then
    echo " ($REMOTE#$BRANCH)"
  fi
}

function directory_trim() {
  # echo "${PWD%/*}" | sed "s;$HOME;~;" | sed -e "s;\(/..\)[^/]*;\1;g" 
  # echo "${PWD%/*}" | sed "s;$HOME;~;" | rev | cut -d'/' -f-1-3 | rev 
  # pwd | sed "s;$HOME;~;" | rev | cut -d'/' -f1-3 | rev
  pwd | sed "s;$HOME;~;" | sed "s;storable;st;" | sed "s;devops;do;" | sed "s;infrastructure;infra;" | sed "s;terraform;tf;" | sed "s;development;dvl;" | sed "s;staging;stg;" | sed "s;production;prd;"
}

# Add color to Terminal:
autoload -U colors && colors
setopt PROMPT_SUBST
# PS1="%{$fg[green]%}%n%{$reset_color%} %{$fg[white]%}(\$(date +"%T"))%{$reset_color%} %{$fg[blue]%}[\$(directory_trim)]%{$reset_color%}%{$fg[yellow]%}\$(git_branch_name)%{$reset_color%} %{$fg[magenta]%}\$(k8s_current_context)%{$reset_color%}
# %% "
PS1="%{$fg[blue]%}[\$(directory_trim)]%{$reset_color%} %{$fg[white]%}(\$(date +"%T"))%{$reset_color%}%{$fg[yellow]%}\$(git_branch_name)%{$reset_color%} %{$fg[magenta]%}\$(k8s_current_context)%{$reset_color%}
%% "

###########
# Aliases #
###########

# File Aliases
if [[ "$OSTYPE" == 'linux'* ]]; then
  alias l="/bin/ls -lh --color"
  alias ls="/bin/ls -h --color"
  alias ll="/bin/ls -lha --color"
  alias la="/bin/ls -ha --color"
else
  alias l="/bin/ls -lhG"
  alias ls="/bin/ls -hG"
  alias ll="/bin/ls -lhaG"
  alias la="/bin/ls -haG"
fi

# Git Aliases
alias gss="git status"
alias gs="git status"
alias gaa="git add ."
alias ga="git add ."
alias gcc="git commit -sm $@"
alias gc="git commit -sm $@"
alias gph="git push origin HEAD"
alias gp="git push origin HEAD"


# Work
alias st="cd ~/storable && ls -lGh"
alias std="cd ~/storable/devops && ls -lGh"
alias stm="cd ~/storable/sparefoot && ls -lGh"
alias sta="cd ~/storable/access && ls -lGh"
alias stp="cd ~/storable/polaris && ls -lGh"
alias stt="cd ~/storable/devops/terraform-modules && ls -lGh"
export AP="storable-access-astria-porta"
export FS="storable-polaris-facility-service"
export TS="storable-polaris-tenant-service"
export CS="storable-polaris-cowsay"
export SLP="storable-sitelink-palantir"
export SLS="storable-sitelink-slapipals"
export ES="external-secrets"
export SSO="storable-polaris-sso-service"
export TW="storable-toast-toast-web"
export TA="storable-toast-toast-api"
export SLIP="storable-sitelink-insurance-processor"
export EBP="storable-polaris-eventbus-proxy"
export PAPI="storable-payments-payments-api"
export DEB="storable-devops-demos-dapr-eventbus"
export DDD="storable-devops-demos-debbie"
export BENJ="storable-devops-benjamin"
export IIS="storable-insurance-insurance-service"
export PPP="storable-payments-payments-portal"
export GPP="storable-devops-demos-gustp-payments-portal"
export GFS="storable-devops-demos-gustp-facility-service"
export GSS="storable-devops-demos-gustp-search-service"
export SCM="storable-storedge-shipping-consumer-manager"
export STSMS="storable-polaris-sms-serivce"

# Program Aliases
alias tf="terraform $@"
alias tplan="terraform plan -out out.plan $@"
alias mk="minikube $@"
# alias dc="docker-compose $@"
# export DOCKER_BUILDKIT=0
alias gc="gcloud $@"
alias tls="tmux ls"
alias gc="gcloud $@"
alias mks="microk8s $@"
alias kls="kubectl config get-contexts"
alias kuse="kubectl config use-context $1"
export KUBE_EDITOR=vim
alias dn="dotnet $@"
alias kn="kubens $@"

# Random Aliases
alias cip="curl https://andyduss.com/ip"
alias lip="ifconfig | grep 'inet '"
alias \:q="exit"
alias c="cd .."

ks() {
  if [[ -f "/snap/bin/microk8s" ]]; then
    microk8s.kubectl "$@"
  else
    kubectl "$@"
  fi
}

tm() {
  if [ $# -eq 0 ]; then
    tmux ls
  else
    tmux ls | grep -q $1
    CPE_EXITCODE=$?
    if [[ "$CPE_EXITCODE" -eq 0 ]]; then
      # 0 => Session is running, attach to existing session
      echo "Attaching to '$1' session ..."
      tmux attach -t $1
    else
      # 1 => Session does not exist, create new session
      echo "Creating new tmux session, $1 ..."
      tmux new -s $1
    fi
  fi
}


tada() {
  # Check if tmux is installed
  if [[ ! -f "/usr/local/bin/tmux" && ! -f "/usr/bin/tmux" ]]; then
    echo "Tmux not found.. exiting..."
    return 1
  fi

  tmux ls | grep -q dflt
  CPE_EXITCODE=$?
  if [[ "$CPE_EXITCODE" -eq 0 ]]; then
    # 0 => Session is running, attach to existing session
    echo "Attaching to 'dflt' session . . ."
    tmux attach -t dflt
  else
    # 1 => Session does not exist, create new session
    echo "Creating new tmux session, 'dflt' . . ."
    tmux new -s dflt
  fi
}

preprod_admin () {
    aws sso login --profile sso-st-preprod-admin
}

jwt-dev() {
    dotnet run \
      --project ~/storable/polaris/jwt-generation-util/src/Storable.Polaris.JwtGenerationUtil \
      --private-key ~/.storable/storable-developer-local.pem \
      --issuer Storable.Developer.Local \
      --kid storable
}

jwt-prod() {
    dotnet run \
      --project ~/storable/polaris/jwt-generation-util/src/Storable.Polaris.JwtGenerationUtil \
      --private-key ~/.storable/storable-access-astria-porta-production.pem \
      --issuer astria-porta.access.storable.io \
      --kid storable
}

tf-check() {
  docker run --rm -it -v $(pwd):/lint -w /lint ghcr.io/antonbabenko/pre-commit-terraform:latest run --all-files
}

tf-doc() {
  pre-commit run --show-diff-on-failure --all-files terraform_docs
}

ssols() {
    if [ -f "$HOME/.aws/credentials" ]; then
      cat "$HOME/.aws/credentials" | grep "\["
    fi
}

fpush() {
    git add . && git commit -sm "chore: $(date)" && git push origin HEAD
}

fffpush() {
    printf "\n" >> README.md && git add . && git commit -m "$(date)" && git push origin HEAD
}

gfeat() {
    git add . && git commit -sm "feat: $1"
}

gfix() {
    git add . && git commit -sm "fix: $1"
}

gchore() {
    git add . && git commit -sm "chore: $1"
}

gopen() {
  if [ $# -eq 0 ]; then BRANCH="origin"; else BRANCH="$1"; fi
  REMOTE=$(git config --get remote.$BRANCH.url)
  if [[ "$REMOTE" =~ "git@" ]]; then
    URL=$(echo "$REMOTE" | awk -F "@" '{print $2}' | awk -F " " '{print $1}' | sed 's/:/\//g' | sed 's/.git//g' | awk '{print "https://"$1}')
  else
    URL=$REMOTE
  fi
  echo "[*] $URL"
  open "$URL"
}

b64() {
    echo $1 | base64 -d
}

# Use bash-completion
if [ -f "/usr/local/etc/profile.d/bash_completion.sh" ]; then
  . /usr/local/etc/profile.d/bash_completion.sh
fi

# Add asdf to PATH
if [ -d "$HOME/.asdf" ]; then
  . $HOME/.asdf/asdf.sh
  export PATH=$PATH:$HOME/.asdf/shims
fi

# Add pyenv to PATH
if [ -d "$HOME/.pyenv" ]; then
  export PYENV_ROOT="$HOME/.pyenv"
  export PATH="$PYENV_ROOT/bin:$PATH"
  eval "$(pyenv init -)"
fi

# Add rbenv to PATH
if [ -d "$HOME/.rbenv" ]; then
  export PATH="$HOME/.rbenv/bin:$PATH"
  eval "$(rbenv init -)"
fi

# Add golang to PATH
if [ -d "/usr/local/go" ]; then
  export PATH="$PATH:/usr/local/go/bin"
fi

if [ -d "$HOME/code/go" ]; then
  export GOPATH="$HOME/code/go"
  export PATH="$PATH:$GOPATH/bin"
fi

# Add Istio to PATH
if [ -d "$HOME/Applications/istio" ]; then
  export PATH="$PATH:$HOME/Applications/istio/bin"
fi

if [ -d "$HOME/.istioctl" ]; then
  export PATH="$PATH:$HOME/.istioctl/bin"
fi

# Add gcloud to PATH
if [ -d "$HOME/Applications/google-cloud-sdk" ]; then
  export PATH="$PATH:$HOME/Applications/google-cloud-sdk/bin"
fi

# Use MySQL from brew
if [ -d "/usr/local/opt/mysql-client" ]; then
  export PATH="/usr/local/opt/mysql-client/bin:$PATH"
fi

if [ -d "$HOME/.dotnet/tools" ]; then
  export PATH="$PATH:$HOME/.dotnet/tools"
fi

if [ -d "$HOME/Applications/kafka" ]; then
  export PATH="$PATH:$HOME/Applications/kafka/bin"
  export CLASSPATH="$HOME/Applications/kafka/bin/aws-msk-iam-auth-1.1.4-all.jar"
fi

if [ -d "$HOME/.linkerd2/bin" ]; then
  export PATH=$PATH:$HOME/.linkerd2/bin
fi

# if [ -f "$HOME/.docker/init-zsh.sh" ]; then
#   source "$HOME/.docker/init-zsh.sh" || true 
# fi

# If podman is installed, use it
PODMAN_SOCKET="$HOME/.local/share/containers/podman/machine/podman.sock"
if [ -L "$PODMAN_SOCKET" ]; then
  export DOCKER_HOST="unix://$PODMAN_SOCKET"
fi

# Add Applications bin to PATH
if [ -d "$HOME/Applications/bin" ]; then
  export PATH="$PATH:$HOME/Applications/bin"
fi
